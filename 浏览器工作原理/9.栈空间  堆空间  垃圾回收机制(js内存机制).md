## 栈空间/堆空间/垃圾回收机制(js内存机制)

#### js语言类型

静态语言:在声明前需要先定义变量类型，即在使用之前需确定变量数据类型。(c)

动态语言:运行过程中检查数据类型(js)

弱类型语言:支持隐式类型转换(c,js)

强类型语言:不支持隐式类型转换

#### js数据类型

![js数据类型](C:\Users\Admin\Desktop\浏览器工作原理小册\image\js数据类型.png)

可以通过`typeof`检测基本数据类型，`intanceof`检测引用数据类型，`Object.prototype.toString.call()`检测具体数据类型

##### 注意

- `typeof`检测`Null`类型时，返回的是`Object`，这是js的一个bug
- `Object`是引用类型，其余都是原始类型

#### 内存空间:代码空间,栈空间,堆空间/数据储存

不同数据类型储存的空间不同，代码空间主要是存储可执行代码的。

##### 栈空间/堆空间

- **原始类型的数据直接储存在栈中，引用类型值存在堆中**，在栈中只保留其对象的引用地址。

- 由于**栈主要用于维护执行上下文的状态**，不能太大，不然会影响执行上下文的切换效率(回收时`esp`指针切换)，所以要分为栈和堆空间。
- 栈空间设置不大，主要用来储存原始类型小数据
- 堆空间很大，能存放很多大数据(分配内存和回收内存会占用一定时间)

##### 赋值/浅拷贝/深拷贝(见9-1)

##### 再谈闭包(概念见7)

```javascript
function foo() {
    var myName = "极客时间";
    let test1 = 1;
    const test2 = 2;
    var innerBar = {
        setName:function(newName){
            myName = newName;
        },
        getName:function(){
            console.log(test1);
            return myName;
        }
    }
    return innerBar;
}
var bar = foo();
bar.setName("极客邦");
bar.getName();
console.log(bar.getName());
```

- js引擎执行到`foo`时，编译创建执行上下文

- 编译遇到内部函数`setName()`时，js引擎会对内部函数进行快速的**词法扫描(预扫描内部函数)**，当发现内部函数引用了`foo`函数对象后，创建一个`"closure(foo)"`对象，将`myName`变量保存到闭包`closure(foo)`中

- 扫描到`getName()`方法时，也一样，将`test1`添加到闭包对象中去(**将内部函数引用的外部变量保存在堆中**)

  ![闭包在内存中](C:\Users\Admin\Desktop\浏览器工作原理小册\image\闭包在内存中.png)

#### 垃圾回收:手动回收,自动回收

- [ ] `c/c++`:手动回收策略，何时分配销毁内存都有代码控制

- [ ] `JavaScript/java/python`:自动回收，产生的垃圾数据由垃圾回收器释放

  - ##### 栈中的数据回收:ESP指针

    **调用栈中有一个记录当前执行状态的指针(ESP),指向当前正在执行的函数**，当函数执行完毕后，ESP指针会下移，就销毁了已执行完的函数的执行上下文。

    ![ESP销毁执行上下文](C:\Users\Admin\Desktop\浏览器工作原理小册\image\ESP销毁执行上下文.png)

  - ##### 堆中的数据回收:垃圾回收器

    代际假说:大部分对象在内存中存在时间很短，如果是不死的对象，会存活更久(`window,document`)。

    堆被分为两个区:

    - [ ] 新生代:存放生存时间短的对象(1~8M)
    - [ ] 老生代:存放生存时间久的对象(更大)

    ##### 垃圾回收器

    由于`JavaScript`运行在主线程上，执行垃圾回收算法时，会使正在执行的`js`脚本暂停，出现**全停顿**现象(造成页面卡顿)。

    ![全停顿](C:\Users\Admin\Desktop\浏览器工作原理小册\image\全停顿.png)

    解决:将标记过程分为多次子标记过程，让垃圾回收标记和js应用逻辑交替进行，直到标记完成(**增量标记算法**)

    ![增量标记算法解决全停顿](C:\Users\Admin\Desktop\浏览器工作原理小册\image\增量标记算法解决全停顿.png)

    垃圾回收器执行流程

    1. 标记空间中的活动对象(还在使用的对象)和非活动对象
    2. 回收非活动对象所占的内存
    3. 内存整理，整理内存碎片

    ##### 副垃圾回收器:负责新生代的垃圾回收

    大多数小的对象分配到新生代区，使用`Scanvenge`算法。

    - 将新生代区对半分为两个区域，一个是对象区域，一个是空闲区域

      ![副垃圾回收机制](C:\Users\Admin\Desktop\浏览器工作原理小册\image\副垃圾回收机制.png)

    - 将新加入的对象放入对象区，当对象区快写满时，执行一次垃圾清理操作

    - 首先将对象区的垃圾做标记

    - **垃圾清理，副垃圾回收器将存活对象复制到空闲区域，将其有序排列(完成内存整理)**

    - 对象区域与空闲区域角色反转

    - 注意:为了执行效率，新生区的空间较小。将**经过两次垃圾回收机制还存活的对象放到老生区**(对象晋升策略,减缓对象区域写满的速度)

    ##### 主垃圾回收器:负责老生代的垃圾回收(占用空间大/存活时间长)

    标记-清除(Mark-Sweep)算法

    - 标记:递归遍历根元素(调用栈)，将能到达的元素称为活动对象(被引用)，未达到的称为垃圾数据
    - 清除垃圾
    - 整理内存碎片(标记-整理算法):让所有存活对象都像一端移动

  