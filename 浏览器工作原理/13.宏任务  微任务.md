## 宏任务/微任务

#### 宏任务:消息队列中的任务。

包括:

- 渲染事件(如解析DOM,计算布局，绘制)
- 用户交互事件(如鼠标点击、滚动页面、放大缩小)
- JavaScript脚本执行事件
- 网络请求完成、文件读写事件

消息队列中的执行通过事件循环来执行，不能保证实时性高的事件的执行。

#### 微任务

##### 异步函数执行方式

- 把异步回调函数封装成**宏任务**，添加到消息队列的尾部，当循环系统执行到该任务时执行回调函数
- **一个异步执行的函数,在当前宏任务结束后(主函数执行结束)执行，通常以微任务体现**

##### 每个宏任务都有一个微任务队列，产生微任务的方式:

- 使⽤`MutationObserver`监控某个`DOM`节点，当`DOM`节点发⽣变化时，就会产⽣`DOM`变化记录的微任务。
- 使用`Promise`，调用`Promise.resolve()`或`Promise.reject()`时产生

##### 执行流程:

1. 当`JavaScript`执⾏⼀段脚本的时候，`V8`引擎会创建全局执行上下文，同时会在内部创建一个微任务队列，用来保存微任务。(无法通过`JavaScript`访问，是给`V8`引擎内部使用的)

2. 当前宏任务中`JavaScript`快执行完成，`js`引擎准备退出全局执行上下文并清空调用栈的时候，会对微任务队列进行检查，按顺序取出微任务到当前宏任务中执行。(这个时间点称为**检查点:`WHATWG`规定的微任务执行时间点)**

3. **当执行微任务过程中产生了微任务，也会添加到当前微任务队列中，并执行，直到队列为空才执行下一个宏任务。**

   ![微任务执行流程](C:\Users\Admin\Desktop\前端\浏览器工作原理小册\image\微任务执行流程.png)

结论:

- [ ] 微任务与宏任务绑定，每个宏任务有自己的微任务队列
- [ ] 微任务的执行时长会影响宏任务的时长
- [ ] 在一个宏任务中创建用于回调的微任务和宏任务，宏任务执行比微任务迟。

#### 应用

`Mutation Observer`是用来监听`DOM`变化的 方法，微任务可以应用在其中使其能够及时监听`DOM`变化并做出响应。

- 早期页面没提供对监听的支持，监控`DOM`变化只能通过`setTimeout/setInterval`轮询来检测
- 2000引入`Mutation Event`观察者的设计模式，当DOM有变化就触发相应事件(同步回调)。会造成性能问题。(已从标准事件删除)
- 引入`Mutation Observer`，将响应函数改成异步调用，还可以等多次`DOM`变化后，一次触发异步调用，还会使用一个数据结构记录这期间所有`DOM`的变化。(异步+减少触发--解决性能问题)
- 每当`DOM`变化时，就把变化记录封装成微任务，添加到当前宏任务的微任务队列中，每次到检查点，`V8`就会按照顺序执行微任务。(微任务--解决实时性)

